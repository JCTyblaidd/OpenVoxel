/**
    This Version is optimized for data storage

    Limitations:    -> Assumes GL_NEAREST is used
                    -> Assumes that normal is the same on a per tri basis
**/
/**[Vertex]**/
#version 330 core
layout(location = 0) in vec3 position;
layout(location = 1) in vec2 uv_coord;
layout(location = 2) in vec3 normal;
layout(location = 3) in vec3 color;
layout(location = 4) in vec4 light_strength;//RGB=Normal Light RGB,A = SkyLight Strength

/**Main Constant Information**/
uniform FrameData {
    mat4 perspMatrix;//Camera -> Screen
    mat4 inversePerspMatrix;//Screen -> Camera
    vec2 depthRange;//Depth Range
    vec2 halfSizeNearPlane;//See other loc//
    mat4 playerMatrix;//World -> Camera
    vec3 celestial_direction;//Celestial WorldSpace Dir
    vec3 celestial_cameraspace_direction;//Celestial CameraSpace Dir
} frameDat;



out vec2 UV;
out vec3 Normal;
out vec3 Color;
out vec4 Light;
out vec3 CameraPos;

void main() {
    Normal = normalize(frameDat.playerMatrix * frameDat.objMatrix * vec4(normal,0.0));
    Light = light_strength;
    UV = uv_coord;
    Color = color;
    vec3 cPos = frameDat.playerMatrix * frameDat.objMatrix * vec4(position,1.0);
    gl_Position = frameDat.perspMatrix * cPos;
    CameraPos = cPos;
}

/**[Fragment]**/
#version 330 core

in vec2 UV;
in vec3 Normal;
in vec3 Color;
in vec4 Light;
in vec3 CameraPos;

uniform TextureAtlas {
    sampler2D tex_diffuse;//diffuse+alpha
    sampler2D tex_normal;//xyz_norm,flags   {TODO: pay attention to the flags}
    sampler2D tex_pbr;//smooth,reflect,ambient,height
} tAtlas;

uniform bool isDrawingTransparent = false;
uniform bool disableDiscard = false;

layout(location = 0) out vec3 diffuse_out;
layout(location = 1) out vec3 normal_out;
layout(location = 2) out vec3 pbr_out;
layout(location = 3) out vec4 light_out;

vec3 getNormal(in vec4 normalRaw) {
    if(Normal.x == 0 && Normal.z == 0) {
        if(Normal.y > 0) {
            return normalRaw.xyz;
        }else{
            return -normalRaw.xyz;
        }
    }else{
        //More Complicated Calculation: TODO check optimization + code  ?Improve: precalc the 3 vec3s in vertex shader
        vec2 n2 = dot(Normal.xz,Normal.xz);
        float xz = Normal.x * Normal.z;
        float scale = (1 - Normal.y) / (n2.x + n2.y);
        float xz_scaled = -xz * scale;
        n2 *= scale;
        mat3 matrix;
        matrix[0] = vec3(1-n2.x,Normal.x,xz_scaled);
        matrix[1] = vec3(-Normal.x,1-n2.x-n2.z,-Normal.z);
        matrix[2] = vec3(xz_scaled,Normal.z,1-n2.z);
        return matrix * normalRaw.xyz;
    }
}

void parallax(out vec4 diffuse, out vec4 pbr_out,out vec4 normal_out,out light_out,out depth_out) {
    //In Camera Space: -> Eye = 0,0,0

}

void main() {
    //Sample//
    vec4 diffuse;
    vec4 pbr_p;
    vec4 normal_p;
    vec4 light_p;
    float depth_p;

    //Run Parallax//
    parallax(diffuse,pbr_p,normal_p,light_p,depth_p);

    if(diffuse.a == 0.0) {
        discard;
    }
    if(!disableDiscard) {
        if(isDrawingTransparent) {//THIS ONLY WORKS BECAUSE OF GL_NEAREST
            if(diffuse.a == 1.0) {
                discard;
            }
        }else{
            if(diffuse.a != 1.0) {
                discard;
            }
        }
    }
    vec3 realNormal = getNormal(normal_p);

    diffuse_out = diffuse.rgb;
    normal_out = real_normal;
    pbr_out = pbr_p.rgb;
    light_out = light_p;
    gl_FragDepth = depth_p;
}


/**[End**/
