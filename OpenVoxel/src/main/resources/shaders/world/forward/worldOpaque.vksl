/**[VK::Vertex]**/

layout(location = 0) in vec3 i_position;
layout(location = 1) in vec2 i_uv_coord;
layout(location = 2) in vec3 i_normals;
layout(location = 3) in vec3 i_tangents;
layout(location = 4) in vec4 i_colour;
layout(location = 5) in vec4 i_lighting;
layout(location = 6) in vec2 i_animation;

out gl_PerVertex {
    vec4 gl_Position;
};

layout(location = 0) out vec2 f_uv;
layout(location = 1) out vec3 f_col;
layout(location = 2) out vec3 f_light;
layout(location = 3) out mat3 f_normMat;


layout(set = 0,binding = 0) uniform FrameConstants {
    mat4 projMatrix;
    mat3 viewMatrix;
    vec3 cameraPos;
    vec3 skyLightDir;
    vec3 skyLightColour;
    int  animationTick;
} worldData;

layout(push_constant) uniform SubChunkMetadata {
    vec3 chunkOffset;
} pushConsts;


void main() {
    //Calculate Animated UV
    int animLimit = int(i_animation.x) * 255;
    int animTick = (worldData.animationTick % animLimit);
    f_uv = i_uv_coord + vec2(0,animTick * i_animation.y);

    //Forward Colour
    f_col = i_colour.rgb;

    //Caulculate Tangent -> World Matrix
    vec3 bi_tangent = cross(i_normals,i_tangents);
    f_normMat = mat3(normalize(i_normals), normalize(i_tangents), normalize(bi_tangent));

    //Caululate Light TODO: correct sky light dropoff?
    vec3 skyLighting = worldData.skyLightColour * i_lighting.a;
    f_light = i_lighting.rgb + skyLighting;

    //Update Position
    vec3 relativePosition = worldData.viewMatrix * (i_position + pushConsts.chunkOffset);
    gl_Position = worldData.projMatrix * vec4(relativePosition,1.0);
}

/**[VK::Fragment]**/

layout(location = 0) in vec2 f_uv;
layout(location = 1) in vec3 f_col;
layout(location = 2) in vec3 f_light;
layout(location = 3) in mat3 f_normMat;

layout(set = 0,binding = 0) uniform FrameConstants {
    mat4 projMatrix;
    mat3 viewMatrix;
    vec3 cameraPos;
    vec3 skyLightDir;
    vec3 skyLightColour;
    int  animationTick;
} worldData;

//RGB=diffuse A=transparency
layout(set = 1,binding = 0) uniform sampler2D atlasDiffuse;
//RGB=normal A=emissiveness
layout(set = 1,binding = 1) uniform sampler2D atlasNormal;
//R=smooth, G=reflect, B=occlusion, A=height
layout(set = 1,binding = 2) uniform sampler2D atlasPBR;

layout(location = 0) out vec4 forward_colour;

void main() {
    //Sample Maps
    vec4 sampleDiffuse = texture(atlasDiffuse,f_uv);
    //vec4 sampleNormal = texture(atlasNormal,f_uv);
    //vec4 samplePBR = texture(atlasPBR,f_uv);

    //Calculate Diffuse:
   // vec3 g_colour = sampleDiffuse.rgb * f_col;

    //Calculate Normal:
    //vec3 g_normal = worldData.viewMatrix * f_normMat * sampleNormal.rgb;

    //Calculate PBR:
    //vec2 g_pbr = samplePBR.tg;

    //Calculate Light:
    //vec3 simple_light = samplePBR.b * (f_light + sampleNormal.a * g_colour);

    //vec3 dx = dFdxFine(f_light);
    //vec3 dy = dFdyFine(f_light);

    //float lighting_scalar = normalize(g_normal).y;
    //float reduced_scalar = lighting_scalar / 2.0 + 0.5f;

    //Final Colour.. TODO: IMPROVE{..} {use PBR}
    //forward_colour = vec4(reduced_scalar * (g_colour + simple_light),1.0);
    forward_colour = vec4(sampleDiffuse.rgb,1.0);
}


/**[VK::End]**/